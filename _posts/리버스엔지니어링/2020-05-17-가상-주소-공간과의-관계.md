---
layout: post
title: "[리버스엔지니어링-이론] 03 - 가상 주소 공간과의 관계"
date: 2020-05-17 18:52:50 +0900
categories: 
    - 리버스엔지니어링
tags:
    - 리버스엔지니어링
    - 페이지
    - MMF
toc: true
notice: "> 본 글은 [이호동 저 '윈도우 실행 파일 구조와 원리로 배우는 리버스 엔지니어링 1권 - 파일 구조 편'](http://www.yes24.com/Product/Goods/32452768?Acode=101)을 보고 공부하면서 정리한 내용입니다."

---

<!-- more -->

## 00 PE 구조와 가상 주소 공간에 로드된 PE 이미지의 관계

- 섹션과 관련해서 고려해야 할 점
    - **파일로 존재하는 PE의 구조**와 이 구조가 **가상 주소 공간(Virtual Address Space, VAS)에 로드되었을 때의 PE 이미지**에 대한 관계
    - 메모리 매핑 파일(Memory Mapping Fiel, MMF)에 대한 이해

## 01 가상 주소 공간과 페이지 파일
- 페이지 파일이란?(페이징 이라고도 함)
    - `PageFile.sys`
    - 물리적으로 존재하는 컴퓨터의 하드 디스크에 숨겨진 시스템 파일
    - 물리적으로 존재하는 RAM 디스크의 공간이 부족할 경우 하드 디스크의 공간의 일부 영역을 RAM처럼 사용하고(가상 메모리 공간) 이를 페이지 파일이라고 한다.
    - 가상의 RAM으로 생각하면 될듯(?)
    - 하드 디스크로부터 데이터를 읽어들일 때 한 다발의 데이터처럼 페이지 파일로 읽으므로 다른 위치의 데이터보다 빨리 읽을 수 있다

- 프로세스는 자신의 구성원이 32bit일 경우 4G(4기가 바이트), 64bit일 경우 16E(16엑사 바이트)의 가상 주소 공간을 가짐
    -말 그대로 **가상 공간**이며, RAM으로 대표되는 실제의 물리적 기억장치와 연결해주는 것이 가상 메모리 관리자(Virtual Memory Manager, VMM)
        - 즉, RAM 공간의 확장이 필요하여 하드디스크의 일정 영역을 제공해주는 것이 VMM(?)
        - **물리적 기억장치는 RAM만을 의미하는 것이 아님**
            - RAM과 하드 디스크 상의 윈도우 시스템이 설치된 논리적 디스크의 루트에 존재하는 `PageFile.sys` 파일을 포함

- 가상 주소 공간에서의 VMM(Virtual Memory Manager) 이란?
    - VMM은 커널모드에 위치하는 윈도우 컴포넌트
    - 동시에 실행될 수십개의 프로세스 각각에 할당될 가상 주소 공간과, 제한된 용량을 갖는 RAM 사이의 중재 역할을 담당.
    - 페이지 파일, RAM, 가상 기억 공간은 VMM에 의해 관리
        - 프로세스에게 마치 자신 혼자 4G, 16E의 선형 주소 공간을 독점하고 있다고 착각하게 만드는 매트릭스를 제공

- 프로세스에 속한 스레드가 가상 주소 공간 내의 특정 번지를 액세스 할 때?
    - VMM은 해당 번지가 소속된, 메모리 관리 단위인 **페이지를 페이지 파일과 매핑**
        - **즉, 가상 주소 공간에 무엇을 읽거나 쓰는 행위는 페이지 파일의 특정 페이지에 동일한 행위를 하는 것**
            - 물론, VMM은 이 페이지 파일 내에 RAM과의 적절한 스와핑을 통해 실제 물리 적인 RAM에 엑세스가 가능하도록 해줌.
            - **가상 주소 공간의 페이지는 페이지 파일과 매핑되어야 사용이 가능**
    - 내가 생각하는 페이지 파일이란?
        - 아마 RAM에서 부족한 공간을 확장하고 하드디스크에 존재하는 페이지 파일(PageFile.sys)를 이용하여 부족한 프로세스를 해당 파일(PageFile.sys)와 스와핑을 통해서 해결하는 것?

- 매핑이란?
    - **가상 주소 공간과 페이지 파일 사이의 페이지 단위의 대응**

- 페이지란?
    - 가상 주소 공간을 관리하기 위해 시스템이 사용하는 메모리의 기본 단위
    - 윈도우는 4KB를 사용
    - 해제(Free), 예약(Reserve), 확정(Commit) 세가지 상태를 가짐
        - 해제(Free)
            - 가상 주소 공간에 영역이 할당되지 않은 상태
        - 예약(Reserve)
            - 해제 상태에서 가상 주소 공간에 VirtualAlloc 등의 함수로 영역을 할당한 상태
            - 예약 상태의 시작번지는 가상 메모리 할당 단위인 64K의 배수 값
            - **단순히 예약만 한다고 해서 해당 메모리를 바로 사용할 수는 없다.**
                - 예약 상태는 가상의 영역에 메모리가 할당된 것에 불과
        - 확정(Commit)
            - 영역을 예약하고 나서 실제로 사용하기 위해서는 해당 영역을 확정상태로 해야한다.
            - 실제 사용을 위해 RAM 등과 같은 물리적 기억 장소와 매핑(예약 공간이 실제 물리적 저장공간과 페이지 단위로 대응된 상태)
            - 즉, **예약된 영역의 페이지를 물리적 기억 장치에 매핑하는 행위**

- 물리적 기억장치 RAM과 DISK의 페이지 스와핑
    - RAM에 특정 페이지가 존재할 경우 특정 페이지에 대한 접근이 가능
        - 반대로 없으면 접근할 수가 없다.
    - `RAM`에 해당 페이지가 존재하지 않을 경우 `디스크 상의 페이지 파일`과의 스와핑을 통해 해당 페이지를 RAM에 로드하여 접근이 가능하게 함
        - RAM에 페이지 (1), (2) 가 있는 경우 스와핑 처리 순서
            - RAM과 페이지 파일의 현재 상태

                ```
                 <RAM>      <DISK>
                [ (1) ]     [ (3) ]
                [ (2) ]     [ (X) ] 
                ```
                
            - 처리 순서
                1. 스레드가 페이지(3)을 요청 
                2. RAM 영역에 페이지(3)이 없고 디스크 상의 페이지 파일로 존재
                    
                    ```
                    <RAM>       <DISK>
                    [ (1) ]     [ (3) ]
                    [ (2) ]     [ (X) ] 
                    ```

                    - RAM 영역에 페이지(3)이 존재해야지 접근이 가능하다.     
                3. RAM에 존재하는 페이지(2)를 디스크 상의 페이지 파일의 빈 페이지(X)에 복사
                    
                    ```
                    <RAM>       <DISK>
                    [ (1) ]     [ (3) ]
                    [ (X) ]     [ (2) ] 
                    ```

                4. RAM의 기존의 페이지(2)위치에 페이지(3)을 로드

                    ```
                    <RAM>       <DISK>
                    [ (1) ]     [ (X) ]
                    [ (3) ]     [ (2) ] 
                    ```

                5. 최종적으로 스레드는 페이지(3)에 접근이 가능

        - 이를 VMM이 관장하게 된다.
    - 따라서, 매핑의 관점에서 보면 물리적 기억장치(RAM+DISK)는 하나의 페이지 파일로 볼 수 있다.
        - 이 페이지 파일은 RAM과 디스크 상의 특정 시스템 파일을 포함한 개념

## 02 메모리 매핑 파일(Memory Mapping File, MMF)

- 매핑된 페이지를 확정된 페이지라고 할 때, **가상 주소 공간의 특정 페이지에 접근한다는 것은 페이지 파일의 일부에 그 페이지가 매핑되어야 함을 의미**

- **가상 기억 공간과의 매핑 대상은 일반 파일도 가능** 
    - 오로지 PageFile.sys라는 시스템 페이지 파일로만 국한 시킬 것이 아니라 직접 열거나 생성한 일반 파일도 가능하다는 의미
    - 이러한 파일 자체가 PageFile.sys의 역할을 대신하는 경우를 `메모리에 매핑된 파일(MMF)` 이라 함

- MMF는 아래의 세 가지 용도로 사용
    1. EXE, DLL 파일의 로드와 실행
    2. 사용자가 직접 디스크 내의 데이터 파일에 액세스
    3. IPC의 수단으로 메모리 공유

- MMF의 특징
    - MMF로 사용되는 파일은 시스템의 페이지 파일을 사용하지 않는다.
        - 해당 파일 자체가 페이지 파일의 역할을 함.
    - **직접 가상 주소 공간에 매핑**된다.
    - EXE나 DLL 등의 실행 파일을 로드할 때 MMF를 이용
        - **PE의 경우 PE 파일 자체가 MMF가 되는 것**

- 실행 파일을 로딩할 때에는 어떠한 변경 없이 그대로 가상 주소 공간에 PE를 매핑
    - 매핑을 위한 가상 주소 공간 상의 로딩 위치나 크기에 관련된 모든 정보가 이미 PE 파일 내에 전부 정의
    - 시스템은 이 PE 파일에 전적으로 의존해서 실행 파일을 가상 주소 공간에 매핑

- PE 파일 자체를 MMF로 사용해서 실행 파일에 로드했을 때 동일 프로그램을 두 개의 프로세스가 작동되도록 했을 경우
    - 하나의 PE 파일을 공동의 페이지 파일로 사용할 것이다.
    - 다만, 하나의 프로세스에서 메모리에 데이터를 쓸 경우 동일한 PE 파일을 페이지 파일로 삼았지만 PE 파일 자체에 대한 변경을 의미하는 것은 아니다.
    - 해당 페이지가 '실행 가능' 속성을 갖게 되면 이 페이지에 대한 '쓰기' 동작을 한 경우 PE 파일은 `Copy-On-Write` 메커니즘을 통해 이루어진다.
        - '실행 가능' 속성을 가진 페이지에 데이터를 갱신할 경우
            - 시스템은 해당 데이터를 갱신하기 직전에 페이지 파일(PageFile.sys)로 복사본을 백업한 후 해당 페이지를 갱신
            - 이러한 메커니즘을 'Copy-On-Write'라 하며 이를 통해 서로 독립적인 프로세스 가상 주소 공간을 유지할 수 있게 된다.