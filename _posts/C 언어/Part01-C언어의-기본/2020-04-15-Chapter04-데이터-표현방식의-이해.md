---
layout: post
title: "[C 언어] Chapter04 - 데이터 표현방식의 이해"
date: 2020-04-15 09:11:38 +0900
categories: 
    - C 언어
tags:
    - C 언어
---

> 본 글은 '윤성우 저 열혈강의 C 프로그래밍' 교재를 학습 후 정리한 글입니다.

<!-- more -->

## 01. n진수
- 'n진수'에서의 n은 데이터를 표현하는데 사용하는 기호의 갯수를 의미
    - 2진수는 0,1
    - 8진수는 0~7
    - 10진수는 0~9
    - 16진수는 0~9, A(10), B(11), C(12), D(13), E(14), F(15)
- 데이터 표현단위인 비트(Bit), 바이트(Byte)
    - 비트
        - 컴퓨터가 표현하는 데이터의 최소 단위로서 2진수 값 하나를 저장할 수 있는 메모리의 크기
    - 바이트
        - 8개의 비트를 묶으면 '바이트'라는 단위가 구성됨.

## 02. 비트, 바이트별 표현할 수 있는 데이터의 수
- 데이터의 수: **2의 비트수만큼 제곱하면 됨**
    - 1bit = 0, 1 = 2^1 = 2개
    - 2bit = 00, 01, 10, 11 = 2^2 = 4개
    - 1byte = 8bit = 2^8 = 256개

## 03. 8진수와 16진수를 이용한 데이터 표현
- 10진수, 8진수, 16진수의 표현 방법
    
    ```c
    int num1 = 10;  // 10진수
    int num2 = 0xA; // 0x로 시작하면 16진수
    int num3 = 012; // 0으로 시작하면 8진수
    ```

    - **여기서 저장되는 값은 전부 다 10이다. 단, 초기화에서 사용된 표현의 방식에만 차이가 있을 뿐이다.**

## 04. 정수의 표현방식
- C언어는 보통 하나의 정수를 4바이트에 표현
    - PC는 0, 1만 표현 가능하다. 그리고 모든 정수는 2진법(0, 1)로 표현이 가능하다.
    - 양수(+)는 모두 표현이 가능하지만 음수(-)의 표현은 어떻게 해야할까 ?
        
        ```
        0 - 0 = 0
        1 - 0 = 1
        1 - 1 = 0
        0 - 1 = -1 (어떻게 해야하지???)
        ```

- 음수를 표현하는 방법 3가지
    - 부호화 절대치(절대값)
        - 부호화 절대치는 최상위비트(MSB)를 부호비트로 사용하고 나머지 자릿수에 정수를 표현하는 방법
            - 1Byte(8bit)에서의 +1, -1의 표현 (양수)
                
                ```
                [ 8bit에서의 +1의 표현 ]
                0  0  0  0  0  0  0  1
                -
                ㄴ> 최상위비트 = 0 = 양수

                [ 8bit에서의 -1의 표현 ]
                1  0  0  0  0  0  0  1
                -
                ㄴ> 최상위비트 = 1 = 음수
                ```

                - 보이는 바와 같이 최상위비트(MSB)를 부호비트로 0은 양수, 1은 음수로 표현함.
        - 부호화 절대치를 이용한 정수표현(4bit)
            
            ```
            정수  이진법    정수  이진법
            +0 = 0000    -0 = 1000 
            +1 = 0001    -1 = 1001 
            +2 = 0010    -2 = 1010 
            +3 = 0011    -3 = 1011 
            +4 = 0101    -4 = 1101 
            ```

        - 문제점
            - 0이 2개 존재(+0과 -1)
                - +0 = 0000, -0 = 1000
            - 덧셈기와 뺄셈기를 구현해야하고 부호비트와 절대값을 구분해서 계산해야하며 뺄셈의 경우 절대값의 크기를 비교해야하는 어려움이 발생 즉, **구현 어려움**
                
                ```
                1) 2+3
                    = 2 + 3 
                    = 0 010 + 0 011 // 부호비트와 절대값을 구분함
                    = 0 101         // 절대값만 더함(양수+양수=양수)
                    = 5
                2) 2-3
                    = 2 - 3
                    = 0 010 - 1 011  // '-'를 계산하는 뺄셈기 필요
                    = -1 011 - 0 010 // 절대값을 비교하여 절대값이 큰것을 왼편에
                    = 1 001 
                ```

            - 비교연산의 모순발생
                
                ```
                1) 3 > 2 = TRUE
                    = 0 011 > 0 010 = TRUE
                2) -2 > -3 = TRUE
                    = 1 010 > 1 011 = FALSE(???) <- 모순발생
                ```

            - 산술식의 문제
                
                ```
                +1 + (-1) = 0 이다. 하지만
                0 001 + 1 001 = 1 010 = -2이 나오는게 이상하다. 
                ```

    - 1의 보수
        - 양수의 각 비트 자릿수를 반전(0->1, 1->0)
            - 부호비트를 그대로 사용가능하며 부호화 절대값을 따로 계산하지 않아도 되고 음수를 더하는 방법으로 뺄셈이 가능하다.
        - 1의 보수를 이용한 정수표현(4bit)
            
            ```
            정수  이진법    정수  이진법
            +0 = 0000    -0 = 1111
            +1 = 0001    -1 = 1110 
            +2 = 0010    -2 = 1101 
            +3 = 0011    -3 = 1100 
            +4 = 0101    -4 = 1010 
            ```

        - 1의 보수의 계산 방법
            - 음수를 1의보수로 취한다.
            - 자리 올림 발생 시 1을 더한다.
            - (-17) + (-4) 문제 풀이
                
                ```
                1. 각 자릿수를 이진법으로 표현
                    +17 = 00010001(2)
                    +4  = 00000100(2) 
                
                2. 각 자릿수를 음수표현하기 위해 1의 보수를 취함
                    -17 = 11101110(2)
                    -4  = 11111011(2)

                3. 1의 보수로 변경된 값을 더한다.
                    1 111111        <- 자리올림 발생
                      11101110
                    + 11111011
                    ㅡㅡㅡㅡㅡㅡㅡㅡ
                     11101001(2)

                4. 자리올림 발생 시 결과값에 1을 더한다.
                            1
                      11101001
                    + 00000001
                    ㅡㅡㅡㅡㅡㅡㅡㅡ
                      11101010(2)
                    -> 결과의 MSB가 1이므로 음수이다.
                       1의보수로 음수를 표현하여 계산했으므로 1의보수를
                       취하면 00010101이 나온다. 즉, 21이 나왔고
                       부호비트에 따라 음수였으므로 -21이 정답이다.
                ```

        - 문제점
            - 0이 2개존재(+0과 -0)
                - +0 = 0000, -0 = 1111
                - 증명
                    
                    ```
                    = 3 + (-3)
                    =    0011  <- +3을 1의보수로 변경
                       + 1100  <- -3을 1의보수로 변경
                       -------
                    =    1111 
                    ```

            - Carry(자리올림) 발생 시 결과값에 1을 더해야 한다.
                - 연산속도가 느려질 수 있음
    - 2의 보수
        - 1의 보수를 구한후 1을 더한다.
        - 장점
            - MSB가 0이면 양수, 1이면 음수라는 성질이 유지된다.
            - 음수를 더하는 방식으로 뺄셈을 할 수 있다.
            - 음수의 비교연산에서 발생하는 모순이 해결된다.
            - 0이 두개나 존재하는 모순이 해결된다.
            - 덧셈과 뺄셈을 구현할 때 캐리를 처리하지 않아도 된다.
        - 2의 보수를 이용한 정수표현(4bit)
            
            ```
            정수  이진법    정수  이진법
            +0 = 0000
            +1 = 0001    -1 = 1111
            +2 = 0010    -2 = 1110 
            +3 = 0011    -3 = 1101 
            +4 = 0101    -4 = 1011 
            ```

        - 2의 보수의 계산 방법
            - 음수를 1의보수로 취한후 1을 더한다.
            - 자리 올림 발생 시 올림수는 버린다.
            - (-17) + (-4) 문제 풀이
                
                ```
                1. 각 자릿수를 이진법으로 표현
                    +17 = 00010001(2)
                    +4  = 00000100(2) 
                
                2. 각 자릿수를 음수표현하기 위해 2의 보수를 취함
                    -17 = 11101111(2)
                    -4  = 11111100(2)

                3. 2의 보수로 변경된 값을 더한다.
                    1 11111        <- 자리올림 발생은 버린다.
                      11101111
                    + 11111100
                    ㅡㅡㅡㅡㅡㅡㅡㅡ
                      11101011
                    -> 결과의 MSB가 1이므로 음수이다.
                       2의보수로 음수를 표현하여 계산했으므로 2의보수를
                       취하면 00010101이 나온다. 즉, 21이 나왔고
                       부호비트에 따라 음수였으므로 -21이 정답이다.
                ```

## 05. 실수의 표현방식
- 적인 bit의 수를 가지고 넓은 범위의 실수를 표현하기 위한 식
    - `±(1.m)x2^e-127`
        
        ```
         |- e --| |-- m -|
        100000001 00000101
        ㄴ> 부호의 표현
        ```

        - 넓은 범위의 실수를 표현할 수 있지만 오차 발생
            - 왜? 0.0을 기준으로 위의 식에서 2의 0승은 절대 0이 될 수 없기에
        - 이러한 오차를 `부동 소수점 오차`라고 한다.
    - 부동 소수점 오차 테스트
        
        ```c
        #include <stdio.h>

        int main(void){
            int i;
            float num = 0.0;

            for(i=0; i<100; i++)
            {
                num += 0.1; // 해당 연산을 총 100회 진행
            }

            printf("0.1을 100번 더한 결과: %f \n", num);
            return 0;
        }
        ```

## 06. 비트 연산자
- 비트 연산자

    |연산자|기능|결합방향|
    |:--:|:--|:----:|
    |&|비트단위로 AND 연산|-->|
    |\||비트단위로 OR 연산|-->|
    |^|비트단위로 XOR 연산|-->|
    |~|단항 연산자로서 피연산자의 모든 비트를 반전|<--|
    |<<|피연산자의 비트 열을 왼쪽으로 이동<br>예) num<<2; // num은 변화 없음, 두 칸 왼쪽 이동 결과만 반환|-->|
    |>>|피연산자의 비트 열을 오른쪽으로 이동<br>예) num>>2; // num은 변화 없음, 두 칸 오른쪽 이동 결과만 반환|-->|

    - & 연산자(AND)
        - 두개의 비트가 모두 1일 때, 1을 반환
        - 계산식
            
            ```
            - 0 & 0 = 0
            - 0 & 1 = 0
            - 1 & 0 = 0
            - 1 & 1 = 1
            ``` 

    - \| 연산자(OR)
        - 두개의 비트중 하나라도 1인 경우, 1을 반환
        - 계산식

            ```
            - 0 | 0 = 0
            - 0 | 1 = 1
            - 1 | 0 = 1
            - 1 | 1 = 1
            ``` 

    - ^ 연산자(XOR)
        - 두 개의 비트가 서로 다른 경우 1을 반환
        - 계산식

            ```
            - 0 ^ 0 = 0
            - 0 ^ 1 = 1
            - 1 ^ 0 = 1
            - 1 ^ 1 = 0
            ``` 

    - ~ 연산자(NOT)
        - 0을 1로, 1을 0으로 반전 -> 보수연산이라고도 부름
        - 계산식
            
            ```
            - ~0 = 1
            - ~1 = 0
            ```

    - << 연산자(왼쪽 이동 Shift)
        - 두개의 피연산자를 요구
        - 계산식
            
            ```c            
                                    //      2진수            10진수
            int num = 15;           // 00000000 00001111

            int result1 = num << 1  // 00000000 00011110 == 30
            int result2 = num << 2  // 00000000 00111100 == 60
            int result3 = num << 3  // 00000000 01111000 == 120
            ```

    - \>> 연산자(오른쪽 이동 Shift)
        - 두개의 피연산자를 요구
        - 계산식
            
            ```c            
                                    //      2진수            10진수
            int num = 15;           // 00000000 00001111

            /**
             * 양수의 경우 0으로 채워지지만
             * 음수의 경우 MSB가 1이므로 
             * CPU에 따라 1로 채워지는 CPU가 있을 수 있고, 
             * 0으로 채워지는 CPU가 있을 수 있다.
            */
            int result1 = num >> 1 
            int result2 = num >> 2
            int result3 = num >> 3
            ```

    - <<, \>> 연산자 특징
        - << 연산자의 경우 이동시킬 때 마다 정수의 값이 두 배가 된다.
        - \>> 연산자의 경우 이동시킬 때 마다 정수의 값이 2로 나누어진다.