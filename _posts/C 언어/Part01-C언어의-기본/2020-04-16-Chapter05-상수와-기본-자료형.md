---
layout: post
title: "[C 언어] Chapter05 - 상수와 기본 자료형"
date: 2020-04-16 05:02:56 +0900
categories: 
    - C 언어
tags:
    - C 언어
---



<!-- more -->

> 본 글은 '윤성우 저 열혈강의 C 프로그래밍' 교재를 학습 후 정리한 글입니다.

## 01. 기본 자료형의 종류와 데이터의 표현 범위
- 정수형

    |자료형|크기|
    |:--:|:-:|
    |char|1Byte|
    |short|2Byte|
    |int|4Byte|
    |long|4Byte|
    |long long|8Byte|

- 실수형

    |자료형|크기|
    |:--:|:-:|
    |float|4Byte|
    |double|8Byte|
    |long double|8Byte 이상|

- 많은 수의 자료형을 제공하는 이유?
    1. 데이터의 표현방식이 다르므로, 최소 둘 이상의 자료형이 필요
        - 정수와 실수는 표현하는 방식이 다르기 때문이다. 즉, **정수와 실수의 자료형이 각각 최소한 하나씩 있어야함**
    2. 메모리 공간의 적절한 사용을 위해서 다양한 크기의 자료형이 필요
        - **메모리의 효율적 사용을 위해**서 다양한 크기의 자료형이 존재
- 연산자 `sizeof`
    - 메모리 공간에서 소모하는 메모리의 크기를 바이트 단위로 계산해서 반환하는 연산자
    - 테스트 코드

    ```c
    #include <stdio.h>

    int main(void)
    {
        int num = 10;
        int sz1 = sizeof(num);
        int sz2 = sizeof(int);

        print("num: %d, sz1: %d, sz2: %d \n",num, sz1, sz2);
    }
    ```

- 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택
    - 값의 범위만 가지고 short나 int냐를 결정할 수는 없다.
        - 왜?

            ```c
            char num1=1, num2=2;
            short num3=300, num4=400;

            printf("%d\n", sizeof(num1+num2))  // 4
            printf("%d\n", sizeof(num3+num4))  // 4
            ```

        - **일반적으로 CPU가 처리하기에 가장 적합한 크기의 정수 자료형을 `int`로 정의한다.**
        - 따라서, int형 연산의 속도가 다른 자료형의 연산속도에 비해서 동일하거나 더 빠르다.
    - [중요]
        - **연산의 횟수가 빈번한 경우에는 저장되는 값의 크기가 작더라도 int형 변수를 선언하는것이 더 좋다.**
        - **데이터의 양이 많아서 연산속도보다 데이터의 크기를 줄어야 하는 경우 char, short형 변수도 사용**

- 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택
    - 실수 자료형의 선택에 가장 중요한 요소는 `정밀도` 이다.
        - 일반적으로 정수의 경우는 int이고 실수의 경우는 `double`을 선택한다.
    - 실수 자료형의 정밀도

        |실수 자료형|소수점 이하 정밀도|바이트 수|
        |:-----:|:-------------:|:-----|
        |float|6자리|4|
        |double|15자리|8|
        |long double|18자리|12|

- unsigned 선언
    - 0 이상의 값만 표현하는 자료형
    - 정수 자료형의 이름 앞에만 사용 가능
    - MSB도 데이터의 크기를 표현하는데 사용
    - 표현할 수 있는 값이 0 이상의 범위로 두 배가 된다.

## 02. 문자의 표현방식과 문자를 위한 자료형
- ASCII(아스키) 코드
    - 문자와 숫자를 연결(mapping)시키는 것
        - A == 65, B == 66 으로 약속
    - 알파벳과 일부 특수문자를 포함한 총 128개의 문자로 이루어짐
- 정수는 출력의 형태에 따라 문자 또는 숫자로 출력된다.

    ```c
    char num = 65;
    char ch = 'A';

    printf("%c", num); // num변수에 숫자 65가 저장됐지만 %c 서식문자로 문자로 출력됨.
    printf("%d", ch); // ch변수에 문자 A가 저장됐지만 %d 서식문자로 숫자가 출력됨.
    ```

- 문자를 표현 시 `char` 자료형을 사용
    - 연산을 위해 `int` 자료형을 추천했지만 이는 연산만을 위한 자료형이고 또, 문자 자료형은 연산이 되지 않으므로 `char`자료형이 더 적합하다.

## 03. 상수에 대한 이해 
- 상수
    - 이름이 있는 상수
        - 심볼릭(Symbolic) 상수
            - 이름을 지니는 상수
            - 표현하는 방법 2가지
                1. 'const 키워드'

                    ```c
                    /**
                     * 상수의 선언은 항상 대문자 !!
                    */

                    const int MAX = 100;        // MAX는 상수 -> 값의 변경 불가능
                    const double PI = 3.1415;   // PI는 상수 -> 값의 변경 불가능

                    const int MAX;  // 쓰레기 값으로 초기화 되어버림(변수를 선언후 초기화를 안하면 생기는 현상)
                    MAX = 100;      // 값의 변경이 불가능하므로 컴파일 에러 발생
                    ```

                2. 매크로를 이용
                    - 추후에 따로 설명
    - 이름이 없는 상수
        - 리터럴(Literal) 상수

            ```c
            int num = 30 + 40;  // 30, 40은 상수

            int inum = 5;       // 정수형 상수
            double dnum = 7.15; // 실수형 상수
            
            // A로 저장돼 보이지만 해당 문자는 컴파일러에 의해 65 정수 값으로 저장 된다.
            // 그리고 해당 크기는 4byte(int)로 저장된다. 
            char ch = 'A';

            float fnum1 = 5.758;    // 경고 메시지 발생
            /* 
             * 위의 fnum1의 변수가 상수 5.758을 저장하는데 경고 메시지가 발생하는 이유는?
             * -> 초기화할 때, 5.758은 double형 상수이고 fnum1은 float형 변수이므로 데이터가 잘려 나갈 수 있다는 메시지가 나온다. 해당 메시지를 해결하기 위해서는 아래와 같이 사용
            */
            float fnum2 = 5.758f;  // 소문자 대문자 구분하지 않는다.
            float fnum3 = 5.758F;  // 소문자 대문자 구분하지 않는다.
            ```

            - num 변수에 값을 대입하기 이전에 30과 40의 덧셈 연산을 위해 메모리 공간에 30과 40을 저장한다. 이때, 30과 40은 이름이 없는 상수 이므로 이를 `리터럴 상수` 또는, 그냥 `리터럴` 이라 함
            - 상수도 자료형을 가진다.
                - int형 자료형을 가진 상수는 int형 메모리 공간에 저장
                - double형 자료형을 가진 상수는 double형 메모리 공간에 저장

## 04. 자료형의 변환
- char형으로 표현되어 있는 데이터의 표현방식을 int형으로 바꿀 때, '자료형의 변환'이라 부름
    - **즉, 자료형의 변환은 데이터의 표현방식을 바꾸는 것**
- 자료형의 변환의 종류
    - 자동 형 변환(묵시적 형 변환)
        - 대입연산의 전달과정에서 발생하는 자동 형 변환
            - 대입 연산시 왼편의 오른편의 자료형이 다른 경우 왼편에 있는 피연산자를 대상으로 변환
                
                ```c
                #include <stdio.h>

                int main(void)
                {
                    // 245는 int이지만 선언된 자료형이 double이므로 double로 자동 변환됨
                    double num1 = 245;
                    
                    // 3.1415는 double형이지만 자동으로 int형으로 변환됨
                    // 정수형이므로 소수점을 제외한 정수 3이 반환됨 -> 소수부의 손실
                    int num2 = 3.1415;

                    /*
                    * 이 경우 4byte int형에서 1byte char형으로 변경 되므로 
                    * '상위 바이트의 손실'이 발생 그리고 부호가 변경될 수 잇음
                    */ 
                    int num3 = 129; // 00000000 00000000 00000000 10000001 -> 129
                    char ch = num3; // 10000001 -> -127

                    printf("정수 245를 실수로: %f \n", num1);       // 245.000000
                    printf("실수 3.1415를 정수로: %d \n", num2);    // 3
                    printf("큰 정수 129를 작은 정수로: %d \n", ch);   // -127
                }
                ``` 

                - 형 변환 시 주의사항
                    - 정수를 실수로 변환
                        - 실수의 표현범위가 정수보다 크기 때문에 손실은 일어나지 않지만 실수이기에 오차가 발생할 수 있음
                    - 실수를 정수로 변환
                        - 소수부가 소멸 됨
                    - 바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 변환할 경우
                        - 상위 비트가 소멸되므로 부호가 변경될 수 있음
        - 정수의 승격(Integral Promotion)에 의한 자동 형 변환
            - CPU가 처리하기에 가장 적합한 크기의 정수 자료형이 `int`
            - 따라서, int보다 작은 크기의 정수형 데이터는 int형 데이터로 형 변환이 됨
                
                ```c
                int main(void)
                {
                    short num1 = 15, num2=25;
                    short num3 = num1 + num2; // num1과 num2가 연산시 int형으로 형 변환
                    
                    printf("num1 15의 사이즈: %d num2 25의 사이즈: %d \n", sizeof(num1), sizeof(num2)); // 2, 2
                    printf("num3의 사이즈: %d \n", sizeof(num3));   // 2

                    // 연산이 이루어지는 경우에만 정수의 승격에 의한 자동 형 변환이 발생
                    printf("num1+num2 의 사이즈: %d \n", sizeof(num1+num2));  // 4
                }
                ```

        - 피연산자의 자료형 불일치로 발생하는 자동 형 변환
            
            ```c
            double num1 = 5.15 + 19;
            ```

            - 위 코드에서 5.15는 실수이지만 19는 정수이므로 해당 결과를 num1이라는 double형 자료형에 대입하기 위해 19가 실수형으로 자동으로 변환된다.
                - 이유는? 실수를 정수로 변환하면 소수부가 소멸되므로 정수를 실수로 변환함
    - 강제 형 변환(명시적 형 변환)
        - 강제로 일으키는 형 변환
            - 형 변환 연산자를 이용해서 강제로 형 변환을 명령하는 것
                
                ```c
                int main(void)
                {
                    int num1=3, num2=4;
                    double divResult;
                    divResult = num1/num2;

                    // 피연산자 num1, num2가 int형으로 나눗셈 결과는 0(정수형 나눗셈 결과의 몫)이된다.
                    printf("num1/num2 나눗셈 결과: %f \n", divResult);          // 0.000000

                    /**
                    * 명시적 변환시 이루어지는 순서
                    * [1] divResult = (double)num1 / num2
                    * [2] divResult = 3.0 / num2
                    * [3] divResult = 3.0 / 4.0    // 산술연산의 형 변환 규칙에 의해 num2에 저장된 값도 변경됨
                    */
                    divResult = (double)num1/num2;
                    printf("(double)num1/num2 나눗셈 결과: %f \n", divResult); // 0.750000

                    return 0;
                }
                ```
                
                ```c
                int main(void)
                {
                    int num1 = 3;
                    double num2 = 2.5 * (double) num1; // (double)로 명시 해줘야 분석하기 좋다. 하지만 명시를 안해줘도 결과는 똑같다.
                }
                ```