---
layout: post
title: "[C 언어] Chapter26 - 매크로와 선행처리기(preprocessor)"
date: 2020-05-04 11:31:30 +0900
categories: 
    - C 언어
tags:
    - C 언어
toc: true
notice: "> 본 글은 '윤성우 저 열혈강의 C 프로그래밍' 교재를 학습 후 정리한 글입니다."
---

<!-- more -->


## 01 선행처리기와 매크로

### 01-1 선행처리
- 실행파일이 컴파일과 링크의 과정을 거쳐서 만들어질 때 **컴파일 이전의 처리**를 말한다.
    - 컴파일: c로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환
    - 링크: 이미 만들어진 기계어 코드를 라이브러리와 연결시켜 실행가능한 상태(.exe)로 생성하는 작업
    - 선행처리: 컴파일 이전

- 실행파일 생성과정
    ![실행파일 생성과정](/assets/c-언어/Chapter26-0001.png)
    - 선행처리의 과정이 컴파일 이전에 이루어짐

- 선행처리기가 하는 일
    - 선행처리의 과정을 거쳐서 생성되는 파일도 그냥 소스 파일
    - 선행처리 명령문대로 소스코드의 일부를 수정(단순 치환의 형태를 띠는 경우가 대부분)
        - 여기서 말하는 명령문은 `#` 으로 시작하는 것(ex `#define`, `#include`)
        - 선행처리의 결과

            ```c
            // 선행처리 이전 소스파일                    // 선행처리 이후 소스파일
            #define PI 3.14      - - - - - - - ->   명령문은 소멸됨

            int main(void)                          int main(void)
            {                                       {
                ....            단순치환(PI -> 3.14)       ....
                num = PI * 3.5; ----[선행처리기]------>     num = 3.14 * 3.5;
                ....                                     ....
            }                                       }
            ```

## 02 대표적인 선행처리 명령문

### 02-1 #define: Object-like macro
- 선행처리 명령문의 구성

    ```c
    #define PI 3.1415
    ```

    - 구조 설명
        - `#define`
            - 지시자
        - `PI`
            - 매크로
        - `3.1415`
            - 매크로 몸체(또는 대체 리스트)
            - 몸체는 생략이 가능하다. 대신, 치환 시 공백으로 대체가 됨(그냥 소멸된다는 뜻)
    - 위의 선행처리 명령문은 매크로 PI를 매크로 몸체 3.1415로 전부 치환하라
    - 결과적으로 PI라는 이름의 매크로는 그 자체로 3.1415가 됐으므로 이와 같은 매크로를 `매크로 상수(또는 오브젝트와 유사한 매크로(object-like macro)`라 한다.

- 예시코드
    
    ```c
    #include <stdio.h>

    #define NAME    "홍길동"
    #define AGE     24
    #define PRINT_ADDR  puts("주소: 경기도 용인시\n"); 

    int main(void)
    {
        printf("이름 %s \n", NAME);
        printf("나이: %d \n", AGE);
        PRINT_ADDR;

        return 0;
    }
    ```
    
    - 함수의 호출문도 매크로로 정의 가능
    - 매크로의 이름정의는 주로 대문자 (이 식별자가 매크로라는 사실을 나타낼 수 있기 때문)

### 02-2 #define: Function-like macro
- 매크로는 매개변수가 존재하는 형태로도 정의 가능
- 매크로 함수의 예
    
    ```c
    #define SQUARE(X) X*X
    ```

    - `SQUARE(X)`의 패턴을 만나면 `X*X`로 치환하라
        - `SQUARE(123);` -> `123*123`
        - `SQUARE(num);` -> `num*num`
    - 위 처럼 선행처리기에 의해서 변환되는 과정 자체를 가리켜 `매크로 확장(macro expansion`이라 한다.

- 예시코드

    ```c
    #include <stdio.h>

    #define SQUARE(X) X*X

    int main(void)
    {
        int num=20;
        
        /* 정상적인 출력 결과 */
        printf("Square of num: %d \n", SQUARE(num));    // 400
        printf("Square of -5: %d \n", SQUARE(-5));      // 25
        printf("Square of 2.5: %g \n", SQUARE(2.5));    // 6.25

        /* 비 정상적인 출력 결과 */
        printf("Square of 3+2: %d \n", SQUARE(3+2));    // 11
        return 0;
    }
    ```
    
    - 비 정상 적인 출력의 결과 이유
        - 매크로는 선행처리기에 의해서 처리가 되므로 해당 문장은 아래처럼 치환이 된다.
            - `SQUARE(3+2)` -> `3+2*3+2` 따라서 결과가 11
        - 이를 해결할 수 있는 방법은?
            - `SQUARE((3+2))` 괄호를 묶어서 `(3+2) * (3+2)` 로 치환됨

### 02-3 매크로 몸체에서의 괄호

```c
#define SQUARE(X) X*X // 제곱을 구하는 매크로
```

- `SQUARE(5)` 는 `5*5` = `25`
- `SQUARE(3+2)`는 `3+2 * 3+2` = `11`이고 `SQUARE((3+2))`는 `(3+2)*(3+2)` = `25`가 나오는 것처럼 사용자에게 주의를 요하는 형태는 안정적이지 못한다.
    - 그래서 아래 처럼 변경을 했다.
        - `#define SQUARE(X) (x)*(X)` 로 변경하게 되면 정상적인 출력 값을 기대 할 수 있다.
            - `SQUARE(3+2)` -> `(3+2) * (3+2)`

- 하지만 위처럼 변경 시 아래 문제에서는 문제가 발생할 수 있다.

    ```c
    int num = 120 / SQUARE(2);
    ```

    - `int num = 120 / SQUARE(2)` 는 `SQUARE(2)`가 `4` 변수 num이 `120/4` 에 의해 `30`으로 초기화 될것으로 기대할 수 있지만 실제로 초기화 값은 `120`이다.
        - `int num = 120/2*2` 이고, 나눗셈이 먼저 계산되므로 `(120/2) * 2`가 되므로 `120`이다.
        - 따라서, 위 매크로의 몸체 `SQUARE(X) (X)*(X)`를 `SQUARE(X) ((X) * (X))`로 변경하자.
            - `int num = 120 / SQUARE(2)` -> `int num = 120/((2)*(2))` 이므로 `120/4`는 `30`이라는 결과가 나온다.

- 즉, 매크로는 아래와 같이 꼭 해야 한다.
    - **몸체 부분을 구성하는 X와 같은 전달인자 하나하나 괄호**
    - **전체를 괄호로 한번 더 묶기**

### 02-4 매크로를 두 줄에 걸쳐 정의
- 두 줄에 걸쳐서 정의 할 경우 `\`(백슬래시) 기호를 사용한다.
    
    ```c
    #define SQUARE(X)   \
            ((X)*(X))
    ```

### 02-5 매크로 정의시, 먼저 정의된 매크로도 사용이 가능

```c
#define PI 3.14
#define PRODUCT(X, Y)   ((X)*(Y))
#define CIRCLE_AREA(R)  (PRODUCT((R), (R)) * PI)

int main(void)
{
    double rad=2.1;
    printf("반지름 %g인 원의 넓이: %g \n", rad, CIRCLE_AREA(rad));

    return 0;
}
```

### 02-7 매크로 함수의 장점
- 매크로 함수는 일반 함수에 비해 실행속도가 빠르다.
    - 일반 함수의 경우 아래와 같은 처리가 이루어지는데 매크로는 단순치환이므로 빠를 수 밖에 없다.
        - 일반 함수의 처리
            - 호출된 함수를 위한 스택 메모리의 할당
            - 실행위치의 이동과 매개변수로의 인자 전달
            - return 문에 의한 갑의 반환
- 지료형에 따라서 별도로 함수를 정의하지 않아도 된다.

### 02-8 매크로 함수의 단점
- 정의하기가 정말로 까다로움
    
    ```c
    int DIFF_ABS(int a, int b)
    {
        if (a>b):
            return a-b
        else:
            return b-a
    }
    ```

    - 위코드를 매크로로 변경해 보아라

        ```c
        #define DIFF_ABS(X,Y) ((X)>(Y) ? (X)-(Y) : (Y)-(X))
        ```
        
        - 괄호나 if,else 같은 조건문을 변형하는데 어려움 즉, 복잡한 함수를 변형하기는 상당히 까다로움

- 디버깅하기가 쉬지 않다.
    
    ```c    
    #define DIFF_ABS(X,Y) ((x)>(y) ? (x)-(y) : (y)-(x))

    int main(void)
    {
        printf("두 값의 차: %d \n", DIFF_ABS(5, 7));
    }
    ```
    
    - 위 코드는 에러가 발생 한다.
        - 에러 코드는 `printf("두 값의 차: %d \n", DIFF_ABS(5, 7));`라고 작성된 부분에 x, y가 없다라는 내용이다.
            - 사실 위 예제에서는 매크로를 정의한 부분에 소문자 x, y를 대문자 X,Y로 바꿔줘야 가능한데 디버깅에서 알려주는 위치가 잘못 됐으므로 디버깅이 어려운 것이다.
                - 사실 디버깅 자체가 컴파일 이후에 발생하지만 선행처리기를 통해서 해당 값이 이미 아래와 같이 변경 된 후에 디버깅을 거쳤으므로 어디가 잘못됐는지 확인이 어려울 것이다.
                    - 변경 전: `printf("두 값의 차: %d \n", DIFF_ABS(5, 7));`
                    - 변경 후: `printf("두 값의 차: %d \n", ((5) > (7) ? (x)-(y) : (y)-(x)) );`
                - 그러므로 x, y를 모른다고 `printf(..` 문에 에러가 발생 된 것이다.

### 02-9 매크로를 정의하는 함수
- 다음 특성을 지니는 함수들을 매크로의 형태로 정의하는 것이 옳다.
    - 작은 크기의 함수
    - 호출의 빈도수가 높은 함수

## 03 조건부 컴파일(Conditional Compilation)을 위한 매크로

### 03-1 #if... #endif: 참이라면

```c
#include <stdio.h>
#define ADD 1
#define MIN 0

int main(void)
{
    int num1, num2;
    printf("두 개의 정수 입력: ");
    scanf("%d %d", &num1, &num2);

#if ADD // ADD가 '참' 이라면
    printf("%d + %d = %d \n", num1, num2, num1+num2);
#endif

// 선행처리리를 통해 아래 코드는 삭제 됨------------
#if MIN // MIN이 '참' 이라면
    printf("%d - %d = %d \n", num1, num2, num1-num2);
#endif
// 위 코드는 삭제 ----------------------------

    return 0;
}
```

- 위 코드는 선행 처리기를 통해서 더하기 연산 부분은 삽입 되고 빼기 연산은 삭제 된다.

### 03-2 #ifdef... #endif: 정의되었다면
- #if...#endif와 유사
    - #if...#endif 는 매크로가 참이냐 거짓이냐 기준
    - #ifdef...#endif 는 매크로가 정의되었느냐 않았느냐를 기준

- 예시코드

    ```c
    #include <stdio.h>
    // #define ADD 1
    #define MIN     // 몸체 생략가능

    int main(void)
    {
        int num1, num2;
        printf("두 개의 정수 입력: ");
        scanf("%d %d", &num1, &num2);

    #ifdef ADD // ADD라는 매크로가 있다면
        printf("%d + %d = %d \n", num1, num2, num1+num2);
    #endif

    #ifdef MIN // MIN이라는 매크로가 있다면
        printf("%d - %d = %d \n", num1, num2, num1-num2);
    #endif

        return 0;
    }
    ```

### 03-3 #ifndef... #endif: 정의되지 않았다면
- 별도 설명은 안하겠다. (03-2의 반대라고 보면 됨)

### 03-4 #else의 삽입: #if, #ifdef, #ifndef
- 예시 코드

    ```c
    #include <stdio.h>
    #define HIT_NUM 5

    int main(void)
    {
    #if HIT_NUM==5
        puts("매크로 상수 HT_NUM은 현재 5입니다.");
    #else
        puts("매크로 상수 HIT_NUM은 현재 5가 아닙니다.");
    #endif
        
        return 0;
    }
    ```

### 03-5 #elif의 삽입: #if에만 해당
- 예시 코드

    ```c
    #include <stdio.h>
    #define HIT_NUM 5

    int main(void)
    {
    #if HIT_NUM==5
        puts("매크로 상수 HT_NUM은 현재 5입니다.");
    #elif HIT_NUM==6
        puts("매크로 상수 HT_NUM은 현재 6입니다.");
    #endif
        puts("매크로 상수 HIT_NUM은 현재 5또는 6이 아닙니다.");
        
        return 0;
    }
    ```

## 04 매개변수의 결합과 문자열화

### 04-1 문자열 내에서는 매크로의 매개변수 치환이 발생하지 않는다.

- 문자열 안에서는 매크로의 매개변수 치환이 발생하지 않는다.
- 따라서 아래의 코드에서의 결과는 다음과 같다.
    
    ```c
    #define STRING_JOB(A, B) "A의 직업은 B입니다."

    int main(void)
    {
        ....
        STRING_JOB(홍길동, 나무꾼)  // 결과는 "A의 직업은 B입니다."
                                // 왜? 문자열은 치환이 발생되지 않음.
        ....
    }
    ```

### 04-2 문자열 내에서 매크로의 매개변수 치환이 발생하게 만들기: # 연산자

- 위 04-1 문제를 해결하기 위한 방법으로 `#` 연산자가 있다.
    
    ```c
    #define STR(ABC)    #ABC
    ```

    - 위 문장은 매개변수 ABC에 전달되는 인자를 문자열 "ABC"로 치환해라 라는 뜻.

- \# 연산자는 치환의 결과를 문자열로 구성하는 연산자
    - 위의 매크로를 대상으로
        - `STR(123)` -> `"123"`
        - `STR(12, 34, 34)` -> `"12, 34, 34"`

- 문자열은 나란히 선언하면, 하나의 문자열로 간주한다.
    - 따라서 아래와 같이 문자열을 선언도 가능
        - `char * str = "ABC" "DEF";`
        - 그리고 이는 다음의 문자열 선언과 동일
            - `char * str = "ABCDEF;`
    - 따라서 다음과 같이 문장을 구성하는 것도 가능
        - `char * str = STR(12) STR(34)`
            - 이는 아래의 같은 선언과 동일 
                - `char * str = "12" "34"`
                - 즉, `char * str = "1234"`

- 결국 위 04-1을 해결하기 위한 방법은 아래 코드이다.

    ```c
    #define STRING_JOB(A, B) #A "의 직업은 " #B "입니다."

    int main(void)
    {
        printf("%s \n", STRING_JOB(홍길동, 나무꾼));
    }
    ```

    - `printf("%s \n", STRING_JOB(홍길동, 나무꾼));` 에서 
    - `printf("%s \n", "홍길동" "의 직업은 " "나무꾼" "입니다.");` 에서
    - `printf("%s \n", "홍길동의 직업은 나무꾼입니다.");` 가 된다.

### 04-3 특별한 매크로 연산자 없이 단순히 연결하는 것은 불가능

- 학번은 주로 입학년도, 학과코드, 고유번호를 토대로 아래와 같이 구성된다.
    - 입학년도: 20
    - 학과코드: 65
    - 고유번호: 175
    - 최종학번 -> 2065175

- 그리고 위 학번을 조합하는 매크로 함수를 정의할때 다음과 같은 형태로 호출
    - `STNUM(20, 65, 175)`

- 해당 문장은 선행처리기에 의해 `2065175` 로 치환이 되어야 한다. 아래는 여러가지 방법을 제안했지만 해결책은 아니다.
    - ~~`#define STNUM(Y, S, P) YSP`~~
        - Y, S, P 조합이 아닌, 하나의 YSP로 인식되므로 전달되는 값 상관없이 YSP로 변환이 이루어짐
    - ~~`#define STNUM(Y, S, P) Y S P`~~
        - 변환과정에서 공백도 그대로 반영되므로 `20 65 175` 라는 세 개의 숫자로 구성이 되는 학번이 만들어짐
    - ~~`#define STNUM(Y, S, P) ((Y)*100000+(S)*1000+(P))`~~
        - 변환과정에서  `STNUM(10, 65, 175)`는 가능하다 대신, `STNUM(10, 65, 075)`에서 P는 같은 75라도 075가 있는데 앞에 붙는 0은 8진수의 표현을 의미하기 때문에  `STNUM(10, 65, 75)` 를 해야 한다. 만일  `STNUM(10, 65, 075)`와 같은 형식으로 호출을 해야 한다면 최선의 해결책이 되지는 못함
    - 정답은 04-4 를 확인
    
### 04-4 필요한 형태대로 단순하게 결합하기: 매크로 ## 연산자
- 위 04-3을 해결하기 위한 방법은 `##` 연산자의 사용
- `##` 연산자
    - 매크로 함수의 전달인자를 다른 대싱(전달 인자, 숫자, 문자, 문자열 등)과 이어줄 때 사용
- 선언예시
    
    ```c
    #define CON(UPP, LOW) UPP ## 00 ## LOW
    ```

    - 위 매크로 몸체에는 UPP와 00 그리고 LOW가 순서대로 이어질 수 있도록 `##`연산자를 사용
        - `int num = CON(22, 77)` -> `int num = 220077;` 로 변환

- 04-3을 해결하기 위한 매크로 선언은 아래와 같이 하면 된다.
    
    ```c
    #define STNUM(Y, S, P)  Y ## S ## P
    ```


