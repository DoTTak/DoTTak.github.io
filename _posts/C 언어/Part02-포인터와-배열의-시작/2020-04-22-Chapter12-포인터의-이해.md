---
layout: post
title: "[C 언어] Chapter12 - 포인터의 이해"
date: 2020-04-22 05:46:50 +0900
categories: 
    - C 언어
tags:
    - C 언어
toc: true
notice: "> 본 글은 '윤성우 저 열혈강의 C 프로그래밍' 교재를 학습 후 정리한 글입니다."
---

<!-- more -->



## 01 포인터

### 01-1 포인터란?
- 메모리의 주소값을 저장하기 위한 변수
- 포인터의 종류
    - 상수 형태의 포인터: 배열
    - 변수 형태의 포인터: 일반적인 포인터 변수

### 01-2 포인터 변수와 & 연산자
```c
int main(void)
{
    int num=7;
    int * pnum;  // 포인터 변수 pnum 선언
    pnum = &num; // 포인터 변수 pnum에 num주소값 저장
}
```
- `int * pnum;`
    - 포인터 변수의 선언
    - 포인트 변수 이름: pnum
    - int형 변수의 주소 값을 저장하는 포인터 변수의 선언: `int *`  
- `pnum = &num;`
    - & 연산자는 오른쪽 피연산자의 주소값을 반환하는 연산자

### 01-3 포인터 변수의 크기
- 4바이트
    - 포인터 변수의 크기는 32비트 시스템에서는 주소값을 32비트로 표현하기 때문
- 8바이트
    - 64비트 시스템에서는 주소 값을 64비트로 표현해야 하기 때문한다.
- 따라서, 주소 값의 크기와 포인터 변수의 크기는 일치

### 01-4 포인터 변수 선언
```c
int * pnum1;            // int * 는 int 형 변수를 가르키는 pnum1의 선언
double * pnum2;         // double * 는 double 태 변수를 가르키는 pnum2의 선언
unsigned int * pnum3;   // unsigned int * 는 unsigned int형 변수를 가르키는 pnum3의 선언
```

### 01-5 포인터의 형(Type)
- int, char, double과 같이 변수의 선언 및 구분에 사용되는 키워드를 `자료형`이라고 하는 것처럼 **포인터 변수의 선언 및 구분에 사용 되는 int \*, char \*, double \* 등을 `포인터 형`이라고 한다.**
    ```c
    int *           // int형 포인터
    int * pnum1;    // int형 포인터 변수 pnum1

    double *        // double형 포인터
    double * pnum2; // double형 포인터 변수 pnum2

    // 즉, 기본원리를 다음과 같다.
    type *      // type형 포인터
    type * ptr; // type형 포인터 변수 ptr
    ```
- 다양한 포인터형이 존재하는 이유
    - 포인터의 형은 메모리 공간을 참조하는 기준이 된다.
        - 즉, 포인터 형에 따른 크기에 따라 반환하거나 참조시 해당 크기에 맞게 반환, 참조를 하기위함
        ```c
        // pnum 포인터가 가르키는 변수를 반환하는데 해당 주소를 시작으로 몇바이트를 읽어 들여야 하는지 모름
        // 이에, 해당 포인터 변수에도 포인터 형을 꼭 지정해야함.
        return *pnum; 
        ```
    - 포인터 기반의 메모리 접근기준을 마련하기 위함.
        - 포인터 형이 존재하지 않는다면 *연산을 통해 메모리 접근이 불가능
            - 왜? 시작은 알지만 끝을 모르기 때문.

## 02 포인터의 연산자(&연산자, *연산자)

### 02-1 &연산자
- 변수의 주소 값을 반환하는 연산자
- 코드
    ```c
    MAX = 2
    int main(void)
    {
        int num = 5;
        double dnum = 0.123;

        // 성공
        int * pnum1 = &num;   // num의 주소값을 반환하고 포인터 변수 pnum에 초기화

        // 에러
        int * pnum2 = &MAX;   // 상수는 불가능

        // 에러
        int * pnum3 = &dnum;  // 변수의 자료형과 포인터형이 다르므로 불가능

        ....
    }
    ```
- 주의할점
    - &연산자의 피연산자의 자료형과 포인터 변수의 포인터형이 일치해야함
    - &연산자의 피연산자는 변수만 올 수 있으며 상수는 불가능하다.

### 02-2 *연산자
- 포인터가 가르키는 메모리 공간에 접근할 때 사용하는 연산자
- 코드
    ```c
    int main(void)
    {
        int num=10;
        int * pnum=&num;     // 포인터 변수 pnum이 변수 num을 가리키게 하는 문장
        *pnum = 20           // pnum이 가르키는 변수(메모리 공간)에 20을 저장
        printf("%d", *pnum); // pnum이 가르키는 변수(메모리 공간)를 부호 있는 정수 출력
    }
    ```

## 03 포인터 변수 사용시 주의할점

### 03-1 초기화의 주의점
- 주의사례
    - 사례 1 - ptr이 가르키는 위치가 어디인지 모르는데 대입하는 경우
        ```c
        int main(void)
        {
            int * ptr;  // 포인터 변수 ptr은 쓰레기 값으로 초기화됨
            *ptr = 200;
        }
        ```
    - 사례 2 - 번지가 무엇을 가르키는지도 모르는데 직접 주소값을 대입하는 경우
        ```c
        int main(void)
        {
            int * ptr = 125; // 125번지가 어디인지 알고?
            *ptr=10;
        }
        ```
### 03-2 널 포인터
- 위 '03-1 초기화의 주의점'을 해결하기 위한 방법
- 포인터 변수를 우선 선언만 해놓고, 이후 유효한 주소 값을 채우기 위한 포인터
    ```c
    int main(void)
    {
        int * ptr1=0;      
        int * ptr2=NULL;    // NULL은 사실상 0을 의미
    }
    ```
    - `int * ptr1=0;`
        - 초기화하는 값 0은 '널 포인터'라 한다. 
        - 0번지를 의미하는것이 아니라 **"아무데도 가르키지 않는다"** 라는 뜻
    - `int * ptr2=NULL`
        - NULL도 '널 포인터'
        - 실제 상수 0으로 정의돼 있음