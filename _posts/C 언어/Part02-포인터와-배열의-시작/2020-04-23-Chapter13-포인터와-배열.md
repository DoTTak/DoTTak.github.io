---
layout: post
title: "[C 언어] Chapter13 - 포인터와 배열"
date: 2020-04-23 02:34:57 +0900
categories: 
    - C 언어
tags:
    - C 언어
toc: true
notice: "> 본 글은 '윤성우 저 열혈강의 C 프로그래밍' 교재를 학습 후 정리한 글입니다."
---

<!-- more -->



## 01 포인터와 배열의 관계

## 01-1 배열의 이름은 포인터

```c
#include <stdio.h>

int main(void)
{
    int arr[3] = {0, 1, 2};
    printf("배열의 이름: %p \n", arr);      // 배열의 이름: 0x7ffeec8337bc 
    printf("첫 번째 요소: %p \n", &arr[0]); // 첫 번째 요소: 0x7ffeec8337bc
    printf("두 번째 요소: %p \n", &arr[1]); // 두 번째 요소: 0x7ffeec8337c0
    printf("세 번째 요소: %p \n", &arr[2]); // 세 번째 요소: 0x7ffeec8337c4

    // arr = &arr[i];   // 컴파일 에러 발생
    return 0;
}
```

- int형 배열 요소간 주소값 차이는 4바이트
- 모든 배열 요소가 메모리 공간에 나란히 할당됨
- 배열의 이름 즉 배열의 포인터는 첫번 째 요소와 동일하다.
    - 즉, 배열의 이름은 배열의 시작 주소 값을 의미, **그 형태는 값의 저장이 불가능한 상수
- 배열의 이름은 포인터이며 그 값을 바꿀 수 없는 `상수 형태의 포인터`
    - 위 `arr = &arr[i];` 라인에서 컴파일 에러가 발생됨으로 증명 가능

### 01-2 포인터 변수와 배열의 이름의 관계

|비교조건|포인터변수|배열의 이름|
|:-----|:-----:|:------:|
|이름이 존재하는가?|존재(포인터 이름)|존재(배열 이름)|
|무엇을 나타내거나 존재하는가?|메모리 주소값|메모리 주소값(배열의 첫번 째 요소의 주소값)|
|주소 값의 변경이 가능한가?|가능(변수자체를 가르키므로)|불가능(상수형 포인터이므로)|

- 배열의 이름은 `상수 형태의 포인터`이며 `포인터 상수`라고도 부름

### 01-3 배열의 이름(포인터 상수)의 * 연산
- 배열의 포인터형
    
    ```c
    int arr1[5];    // arr1은 int형 포인터 상수
    double arr2[5]; // arr2은 double형 포인터 상수
    ```

    - 1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정
        - 즉, 배열의 이름이 배열의 첫번 째 요소의 주소값을 가르키는 포인터 이므로 첫번 째 요소의 자료형을 가짐
- 관련 코드
    
    ```c
    #include <stdio.h>

    int main(void)
    {
        int arr1[3]={1, 2, 3};
        double arr2[3]={1.1, 2.2, 3.3};

        printf("%d %g \n", *arr1, *arr2);       // 1 1.1 
        *arr1 += 100;
        *arr2 += 120.5;
        printf("%d %g \n", arr1[0], arr2[0]);  // 101 121.6 
        
        return 0;
    }
    ```


### 01-4 포인터를 배열의 이름처럼 사용
- 포인터 변수와 배열의 이름은 변수냐 상수의 차이이다.
    - 즉, 포인터 변수에서 사용되는 연산은 배열의 이름으로 가능
    - 반대로, 배열의 이름으로 사용되는 연산은 포인터 변수도 가능
- 코드
    
    ```c
    #include <stdio.h>

    int main(void)
    {
        int arr[3]={15,25,35};
        int * ptr=&arr[0];  // int * ptr=arr과 동일

        printf("%d %d \n", ptr[0], arr[0]); // 15 15
        printf("%d %d \n", ptr[1], arr[1]); // 25 25
        printf("%d %d \n", ptr[2], arr[2]); // 35 35
        printf("%d %d \n", *ptr, *arr);     // 15 15

        return 0;
    }
    ```


## 02 포인터 연산

### 02-1 포인터를 대상으로 하는 증감 연산
- 포인터 변수는 주소값을 저장한다. 그리고 해당 주소값의 증감 연산도 가능
    
    ```c
    int main(void)
    {
        int * ptr1 = 0x0010;
        double * ptr2 = 0x0010;

        printf("%p %p \n", ptr1+1, ptr1+2); // (4byte)int형이므로 각각 4, 8씩 증가
        printf("%p %p \n", ptr2+1, ptr2+2); // (8byte)double형이므로 각각 8, 16씩 증가

        printf("%p %p \n", ptr1, ptr2);
        ptr1++; // (4byte)int형이므로 4증가
        ptr2++; // (8byte)double형이므로 8증가
        printf("%p %p \n", ptr1, ptr2);
        
        return 0;
    }
    ```

    - 즉, 포인터 형에 따른 증가, 감소 연산의 결과는 다음과 같다.
      
        |포인터형|연산|결과값|
        |:---:|:--:|:---:|
        |int형|n 증가|n x sizeof(int)만큼 증가|
        |double형|n 증가|n x sizeof(double)만큼 증가|
        |int형|n 감소|n x sizeof(int)만큼 감소|
        |double형|n 감소|n x sizeof(double)만큼 감소|
      
         - Type형 포인터를 대상으로 n의 크기만큼 증가, 감소를 하게되면 `n x sizeof(Type)`만큼 증가, 감소 하게 된다.

- 연산을 이용해 배열의 접근도 가능
    
    ```c
    int main(void)
    {
        int arr[3] = {11, 22, 33};
        int * ptr = arr;
        printf("%d %d %d \n", *ptr, *(ptr+1), *(ptr+2)); // 11 22 33

        printf("%d ", *ptr); ptr++; // 11   printf 함수 호출 후, ptr++ 실행
        printf("%d ", *ptr); ptr++; // 22   printf 함수 호출 후, ptr++ 실행
        printf("%d ", *ptr); ptr--; // 33   printf 함수 호출 후, ptr-- 실행
        printf("%d ", *ptr); ptr--; // 22   printf 함수 호출 후, ptr-- 실행
        printf("%d ", *ptr); ptr--; // 11  
        printf("%d ", *ptr);        // 0  
        printf("\n");

        return 0;
    }
    ```

    - **`arr[i] == *(arr+i)`**

- \*(++ptr)연산과 \*(ptr+1)연산
    - `*(++ptr)`: ptr 포인터변수 자체 값이 변경됨
    - `*(ptr+1)`: ptr 포인터변수 자체 값은 변경 안됨

## 03 상수 형태의 문자열을 가르키는 포인터

### 03-1 두 가지 형태의 문자열 표현
- 두 가지 형태의 문자열
    
    ```c
    char str1[] = "My String";
    char * str2 = "Your String";
    ```

    - str1은 배열을 기반으로한 `변수 형태의 문자열 선언`
        - 변수라 함은 문자열의 일부를 변경할 수 있기 때문
    - str2는 포인터를 기반으로한 문자열
        - 문자열의 첫 번째 문자 Y의 주소 값이 반환되어 포인터 변수 str에 저장
    - **즉, str1은 계쏙해서 문자 M이 저장된 위치를 가르키는 상태이어야 하지만 포인터 변수 str2는 다른 위치를 가르킬 수 있다.**

### 03-2 변수, 상수형태의 문자열

```c
int main(void)
{
    char str1[] = "My String";   // 변수 형태의 문자열
    char * str2 = "Your String"; // 상수 형태의 문자열
    printf("%s %s \n", str1, str2);

    str2="Our String";  // 변경 가능
    printf("%s %s \n", str1, str2);

    str1[0] = 'X';      // 변경 가능
    // str2[0] = 'X';   // 변경 불가능
    printf("%s %s \n", str1, str2);

    return 0;
}
```

- str1은 배열이름. 즉, 상수 형태의 포인터 이므로 값(가르키는 대상)의 변경이 불가능 하다.
    - 대신, **배열을 대상으로는 값의 변경이 가능하기 때문에 이러한 문자열을 `변수 형태의 문자열`이라고 한다.**
- str2 `상수 형태의 문자열`
    - 실제로 `str2[0]`에 변경이 불가능 한 것처럼 포인터 변수로 선언하고 문자열로 초기화 하는 `상수 형태의 문자열`은 그 내용의 변경이 불가능

### 03-3 상수 형태의 문자열
- 상수 형태의 문자열의 모양
    
    ```c
    char * str = "Const String"
    ```

    - 먼저, 큰 따옴표(")로 묶어진 문자열이 메모리 공간에 저장되고 해당 메모리 주소값이 반환됨.
        - 즉, 포인터 변수 str은 'Const String'이 저장된 메모리 공간의 시작 번지를 저장하게 된다.
    - 이는 똑같이 함수에서도 적용된다.
        
        ```c
        printf("Show you string"); 

        // 위 문자열도 메모리 공간에 저장된 후 다음의 형태가 된다.(0x1234번지에 저장되었다고 가정)
        // 이렇듯 문자열을 통째로 전달받는 함수가 아닌, 문자열의 주소 값을 전달 받는 함수
        printf(0x1234);

        // 따라서 실제 함수에 매개변수로 문자열을 전달 할 때에도 함수의 매개변수 선언이
        // 다음과 같을 수 있다.
        TestFunc("Hello");
        void TestFunc(char * str){...} // 실제 전달되는건 문자 H의 주소 값
        ```


## 04 포인터 배열(포인터 변수로 이뤄진 배열)

### 04-1 포인터 배열의 이해
- 주소 값의 저장이 가능한 배열을 가르켜 `포인터 배열`이라 한다.
- 선언 방식
    
    ```c
    int * arr1[20];     // 길이가 20인 int형 포인터 배열 arr1
    double * arr2[30];  // 길이가 30인 double형 포인터 배열 arr2
    ```

### 04-2 문자열을 저장하는 포인터 배열
- 사실상 char형 포인터 배열
- 선언 방식
    
    ```c
    char * strArr[3];   // 길이가 3인 char형 포인터 배열 strArr
    ```

- 예시
    
    ```c
    char * strArr[3] = {"One", "Two", "Three"};

    printf("%s \n", strArr[0]); // One
    printf("%s \n", strArr[1]); // Two
    printf("%s \n", strArr[2]); // Three
    ```

    - 위 문장이 실행되면?
        1. 초기화 리스트에 선언된 문자열은 메모리 공간에 저장
        2. 그 위치에 저장된 문자열의 주소 값이 반환
        3. 따라서 `char * strArr[3] = {0x00.., 0x00.., 0x00..}`의 형태로 저장됨
            - 결국 해당 배열은 아래와 같은 구조를 가지게 된다.
                ```
                strArr[0] ----> One\0
                strArr[1] ----> Two\0
                strArr[2] ----> Three\0
                ```
