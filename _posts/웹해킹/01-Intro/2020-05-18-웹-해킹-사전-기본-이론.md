---
layout: post
title: "[웹해킹-기초] 01 - 웹 해킹 사전 기본 이론"
date: 2020-05-18 23:32:50 +0900
categories: 
    - 웹해킹
tags:
    - 웹해킹
toc: true
notice: "> 본 글은 [[인프런] 크리핵티브](https://www.inflearn.com/instructors/213605/courses)님의 [반드시 알고 넘어가야 할 웹 기술 기초편](https://www.inflearn.com/course/%EC%9B%B9-%EA%B8%B0%EC%88%A0-%EA%B8%B0%EC%B4%88) 강의를 듣고 정리한 글 입니다.\n
> - 참고 URL\n
>   - [위키백과](https://ko.wikipedia.org/wiki/)"
---

<!-- more -->

## 01. 웹 해킹을 공부하기 전 웹 기초 지식
- 웹 해킹을 공부하기 전 웹 기초 지식이 필요한 이유
    - 웹 공간 내 취약성 진단을 위해 최소한의 지식이라는 것이 반드시 필요하므로
        - 결국엔 발견된 취약점에 대한 설명과 대응책 수립을 위해 웹의 흐름(?)을 알아야 할 것 같다.
            - 웹의 취약점 진단의 흐름
                1. 웹 기초에 대한 이해
                2. 웹 어플리케이션에 대한 이해
                    - PHP, JSP, ASP
                3. 웹 어플리케이션 로직에 대한 이해
                    - 게시판(회원관리, 로그인, 로그아웃)
                4. 취약점에 대한 이해
                5. 응용 취약점에 대한 이해
                6. 대응책 수립

## 02. 웹 기초 지식 및 관련 키워드
- 월드 와이드 웹(World Wide Web, WWW, W3)
    - 인터넷에 연결된 컴퓨터를 통해 사람들이 정보를 공유할 수 있는 전 세계적인 정보 공간
    - 웹(Web)이라 부르는 경우가 많음

- 웹의 탄생
    - 최초 웹은 유럽 입자 물리학 연구소(CERN)의 연구원 팀 버너스 리 박사에 의해 탄생
    - 멀리 떨어져 있는 동료 연구자와 지식을 공유하기 위해 고안된 기술로 하이퍼 텍스트 중심으로 구성

- 하이퍼텍스트(HyperText)
    - 1960년대 컴퓨터 개척자 테오도르 넬슨이 처음 사용
    - 'Hyper', 'Text'를 합성하여 맏는 컴퓨터 및 인터넷 관련 용어
    - 한 문서에서 다른 문서(텍스트)로 접근(초월)할 수 있는 일종의 링크

- 웹 브라우저의 탄생
    - MS사의 인터넷 익스플로러(Internet Explorer)
    - 구글의 크롬(Chrome)
    - 애플의 사파리(Safari)
    - 모질라 재단의 파이어폭스(Firefox)

- 웹의 기본 구조, 클라이언트/서버 구조
    - 웹은 클라이언트와 서버 구조로 되어 있다.
        - 클라이언트 측은 사용자 즉, 웹 브라우저
        - 서버 측은 웹 서버 혹은 웹 어플리케이션 서버
            - 웹 서버에 따라 PHP, JSP, ASP등 사용되는 언어는 다름

- 클라이언트/서버 통신 원리
    - 클라이언트와 서버간의 관계
        - 클라이언트는 서비스를 제공 받음
            - 클라이언트는 서버로 요청을 보내는 것을 HTTP 요청 메시지(HTTP Request Message)
        - 서버는 서비스를 제공함
            - 서버는 클라이언트로 응답을 보내는 것을 HTTP 응답 메시지(HTTP Response Message)

- 웹의 3대 요소
    - URL(Uniform Resource Locator)
        - 통합 자원 지시자
        - 인터넷 상의 모든 리소스를 요청할 수 있다.
        - HTTP, FTP, SMTP 관련된 자원 요청도 가능
        - URL 구조
            - `http`://`www.test.co.kr`/`view`/`board.do` `?` `gubun` `=` `notice` `&`idx=100
                - `http`
                    - 프로토콜(http)을 통해 자원을 요청(ftp, file, https 등이 있다.)
                - `www.test.co.kr`
                    - 서버 주소인 호스트 부분
                    - 포트번호가 표시되어야 하지만 HTTP는 기본포트가 80포트를 사용하므로 생략 가능
                - `view`
                    - 자원이 존재하는 디렉터리
                - `board.do`
                    - 요청할 자원의 이름
                - `?` `gubun` `=` `notice` `&`idx=100
                    - `?` 
                        - 파라미터의 시작
                    - `gubun` 
                        - 파라미터의 Key
                    - `notice` 
                        - gubun이라는 key에 대입할 값
                    - `&`
                        - 파라미터 여러개를 사용하기위한 접두사(?)
    - HTML
        - URL을 통해 자원을 요청 후 응답(요청의 결과)을 클라이언트에 출력하기 위함(웹 브라우저가 이를 해석함)
    - HTTP
        - 웹 서버와 웹 클라이언트 간에 통신을 하기위한 규약

- URL 인코딩(URL Encoding)
    - URL 상에서 문자를 표현하는 방법
    - 데이터 전송 상에 손실을 막기 위한 방법
    - **웹 브라우저를 사용할 경우 브라우저에서 URL 인코딩은 자동으로 해줌**
    - 사용 예시
        - `http://www.test.com?id=user001&pw=!@#$qwe`
        - URL 에서 `#` 문자 뒤로 나오는 부분은 무시를 하게된다.
            - 이에 그대로 전송이 된다면 비밀번호가 `!@#$qwe` 인데 `#` 뒤의 `$qwe`가 사라져버림
            - 그래서 이러한 기호는 인코딩을 통해 아래처럼 변환된다.(예시이므로 실제로는 아래처럼 변경되지 않음)
                - `http://www.test.com?id=user001&pw=!@%23%24qwe`
                    - `%23`, `%24`는 각각 `#`, `$`의 URL 인코딩 변환이다. 

- HTTP 버전
    - HTTP/0.9
        - 최초로 웹이 만들어질 때 오직 HTML을 받아 오기위해 만들어 졌다.
        - GET 메소드만 지원
    - HTTP/1.0
        - HTTP 정식 사양으로 처음 알려짐
        - **각 요청마다 새로운 연결을 맺고 끊고 다시 새로운 연결을 맺는 비효율 적인 비 연결지향 방식**
            - 매 요청시 새로 연결하고 끊어야 하므로 속도 저하의 요인
            - 새로고침 시 또 요청을 하게되는 비효율성
    - HTTP/1.0+
        - 비효율 적인 연결의 문제를 해결하기 위해 **Keep-Alive Connection** 을 지원하여 여러 번 커넥션을 맺는 문제를 해결
    - HTTP/1.1
        - 현재 가장 많이 사용되고 있는 버전
        - HTTP/1.0+의 성능을 최적화
        - Keep-Alive는 명세에서 빠지고 모든 요청이 끝나면 **Connection: close** 헤더를 통해 연결을 종료
        - GET, POST, HEAD 3가지 뿐인 메소드에 OPTIONS, PUT, DELETE 등 많은 메소드가 추가
    - HTTP/2.0
        - 요즘 웹의 경우 하나의 웹 페이지를 보기 위해 수십개의 요청을 보내야 정상적으로 페이지를 볼 수 있는데 이런 문제를 해결하기 위함
            - 하나의 페이지에 접속하려면 여러 개의 이미지, CSS, JS를 요청해야함
        - 성능 향상에 초점을 둔 프로토콜로 멀티플렉싱 스트림, 헤더 압축, 서버 푸시 등의 기능이 추가
        - Google 계열 사이트는 HTTP/2 를 지원(하지만 국내 사이트는 HTTP/1.1만을 지원)

- TCP/IP 통신
    - 대부분의 네트워크 통신은 TCP/IP 기반 통신
    - 이때 통신을 우한 중요한 정보가 바로 IP, PORT
    - IP를 통해 물리적 호스트 대상을 찾으며 PORT를 통해 논리적 대상을 찾음
    - 사용자와 웹 서버간의 통신을 맺을 때 제일 먼저 하는 것이 `3-way-handshake`

- HTTP 프로토콜의 연결 관리 방식
    - 비 지속 연결
        - HTTP/0.9, HTTP/1.0
        - 리소스 요청 시 매 번 3-ways-handshake를 수행 해야 하기 때문에 오늘날의 웹과 부적합한 연결 방식
    - 지속 연결
        - HTTP/1.0+, HTTP/1.1, HTTP/2.0
        - 리소스 요청 시 처음에만 3-ways-handsake를 수행(Keep-Alive)
    
- HTTP 메시지
    - 요청 메시지 구조
        - `시작줄` + `\r\n`
            - 시작줄은 메서드와 요청 URL과 버전 명시
                - 예시) `POST /login.php HTTP/1.1`
        - `메시지 헤더` + `\r\n\r\n`
            - 메시지 헤더는 `헤더명: 헤더값` 형식으로 들어가고 `\r\n`을 기입해서 더 추가할 수 있다.
            - 단, 메시지 바디영역과의 구분을위해 `\r\n\r\n` 이 들어간다.
        - `메시지 바디` + `r\n`
    - 응답 메시지 구조
        - `시작줄` + `\r\n`
            - 시작줄은 버전, 상태 코드, 응답 문구
                - 예시) `HTTP/1.1 200 OK`
        - `메시지 헤더` + `\r\n\r\n`
        - `메시지 바디` + `r\n`

- HTTP 메서드 GET/POST
    - 일반적으로 웹 통신시 가장 많이 사용되는 메소드
    - 클라이언트에서 서버에 데이터를 전달할 때 사용

- HTTP 상태 코드
    - 1xx 정보
    - 2xx 성공
        - 200 OK: 정상적으로 처리
    - 3xx 리다이렉션
        - 302 Found: 다른 페이지로 이동
        - 304 Not Modified: 수정되지 않음
    - 4xx 클라이언트 에러
        - 400 Bad Request: 클라이언트 요청에러
        - 403 Forbidden: 접근 권한 없음
        - 404 Not Found: 존재하지 않음
    - 5xx 서버 에러
        - 500 Internet Server Error: 서버 쪽 에러
    - Tip
        - **상태 코드에 따른 출력되는 에러 페이지가 서버 별로 다르므로 이를통해 웹 서버 혹은 웹 어플리케이션 서버를 식별 할 수 있다,**

- 쿠키와 세션
    - 상태 유지 및 관리, 사용자 인증 수단을 위해 사용
    - 사용자 식별 및 세션 유지를 통해 클라이언트와 서버 간의 상태 관리를 함
    - 가장 많이 사용되고 있는 인증 방식
    - 일반 적으로 말하는 쿠키는 지속쿠키, 세션은 세션쿠키
        - 지속 쿠키
            - 웹 서버에서 발급시 클라이언트 하드 디스크에 텍스트 형태로 저장
            - PC 사용자는 쿠키 정보 열람 가능
            - 단점
                - **폐기 이후에도 재사용이 가능 하므로 평문인 경우 변조의 위협**이 있기 때문에, 사용자 인증 관리를 위해서는 암호화과정을 거쳐야 하는 등 보안과 관련한 쿠키 발급 로직을 구현해야함 
        - 세션 쿠키
            - 웹 서버에서 발급 시 클라이언트 웹 브라우저 캐시에 저장됨
            - 세션을 저장하는 방법 크게 3가지
                - 메모리
                - 파일 시스템
                - 데이터베이스
            - 세션은 암호화가 아닌 랜덤의 문자열을 생성해 해당 문자열과 실제 정보를 매핑하는 방법으로 이용
    - 지속쿠키와 세션쿠키는 편리함과 서버의 부하율 즉, 웹 서비스의 규모와 인프라 구성에 알맞게 사용해야 한다.

- 웹 아키텍처
    - 일반적인 웹 아키텍처
        - 클라이언트
            - HTML, JS, CSS
        - 웹 서버
            - PHP, JSP, ASP
        - 데이터베이스
            - Oracle, MySQL, MsSQL

- 웹 아키텍처의 동작 원리 분석
    1. 웹 브라우저의 동작
        - 웹 사이트 접속(URL 입력)
        - 도메인 -> IP 변환
            1. 로컬 DNS Cache(`$ ㅑㅔ채ㅜ럏 /야네ㅣ묘운`) 확인
            2. hosts 파일 참조
            3. DNS 서버 질의
        - HTTP 요청
    2. HTTP 프로토콜 요청은 TCP/IP를 기반으로 3-ways-handshake를 거친 후 데이터를 전송
    3. 웹 서버에서 요청에 따라 DB 연결 및 질의를 통해 응답 메시지 반환

- 클라이언트
    - 대표적으로 웹 브라우저(인터넷 익스플로러, 크롬, 사파리 등)
    - 사용자가 입력한 URL을 이용해 서버에 자원을 요청 후 응답을 받아 사용자에게 GUI 환경을 제공

- 웹사이트 구조 분석
    - HTML
        - 웹에 가독성 있는 인터페이스를 제공
    - CSS
        - HTML에 가독성을 더하기 위함(스타일 제공)
    - JS
        - 동적인 인터페이스 구성
        - 웹 서버와의 통신을 위함
        - 오늘 날 Ajax라는 비동기 통신 기술로 동기화(새로고침 또는 페이지 이동) 없이 비동기적(일정 영역만 변경)으로 웹 서비스를 이용 할 수 있다.
            - 새로고침 시 매번 렌더링(자원 요청)을 해야하므로 웹 서버의 부하를 줄일 수 있다.

- 웹서버(ws)와 웹 어플리케이션 서버(was)
    - 웹 서버
        - 클라이언트 자원 요청에 따른 웹서비스 제공
        - 정적인 컨텐츠 자원 제공을 담당
        - 종류
            - 아파치
            - IIS
            - Nginx
            - 등등
    - 웹 어플리케이션 서버
        - 동적인 컨텐츠 자원 제공을 담당

- 웹 루트, 도큐먼트 루트, 웹 디렉터리
    - URL로 서버에 자원을 요청할 때, 웹 서버에서 바라보는 경로
    - 이를 이용해 **파일 다운로드/업로드 취약점 공격**에 많이 활용됨

- 2-Tier, 3-Tier 동작
    - 2-Tier
        - 사용자 <-> 웹 서버
    - 3-Tier
        - 사용자 <-> 웹 서버 <-> 웹 어플리케이션 서버
        - 정적 자원을 요청한 경우 웹 서버에서 처리 후 응답 메시지를 전달
        - 동적 자원을 요청한 경우 웹 서버는 웹 어플리케이션 서버로 포워딩을 하여 로직에 따라 처리 후 응답메시지를 사용자에게 전달
            - 로직 상태에 DB 질의가 있는 경우 DB와 연결

- 웹 서버와 웹 어플리케이션의 분리하는 이유
    - 웹 서버는 정적 자원 처리에 대해 최적화
    - 웹 어플리케이션 서버는 동적 자원 처리에 최적화
    - 위 두가지를 바탕으로 업무 분담을 하여 자원 처리에 대한 효율성을 극대화

- 데이터베이스
    - 동적인 컨텐츠를 제공하기 위해 데이터를 저장해두는 저장소
        - 글을 쓰고, 읽고, 수정하고, 삭제하고

- Client Script/Server Script 의 보안 검증
    - 보안검증은 필히 Sever Script
        - Client Script에서 보안 검증을 할 경우 Porxy 도구(Burp Suite)를 이용하여 검증 로직을 우회할 수 있으므로
